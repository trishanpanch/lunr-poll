# Project Post-Mortem & Best Practices Guide

## ðŸ“… Changelog: Key Updates (Last 48 Hours)

A summary of the critical transformation from a prototype to a production-ready cloud application.

### 1. Architecture: From "Local Mock" to Cloud Native
*   **Removed**: The entire `localStorage` simulation layer. All code relying on `window.localStorage` for session/user management was removed.
*   **Added**: Full **Google Cloud Firestore** integration.
    *   Sessions are now created, read, and updated in real-time using Firestore listeners (`onSnapshot`).
    *   Data persists across devices and browser sessions.

### 2. Authentication Overhaul
*   **Fixed**: Replaced the "Bypass" login mechanism with strict **Firebase Authentication**.
*   **Security**: Implemented **Client-Side Route Guards**.
    *   `/professor/dashboard` now strictly checks for a valid Firebase User object.
    *   Unauthenticated access is immediately blocked/redirected.
*   **Error Handling**: Added specific error catching for `auth/email-already-in-use` to prevent UI crashes during sign-up.

### 3. Deployment Pipeline
*   **Created**: A robust `deploy.sh` script.
*   **Flow**: Automated the `npm run build` -> `docker build` -> `gcloud run deploy` pipeline.
*   **Config**: Standardized `next.config.ts` and `cloudbuild.yaml` for consistent builds on Google Cloud Run.

### 4. UI/UX Polish
*   **Landing Page**: Built a new, premium "Harvard Aesthetic" landing page with dual-path routing (Professor vs. Student).
*   **Feedback**: Added `sonner` for toast notifications (success/error messages) to give users immediate feedback.

---

## ðŸš€ Lessons Learned: Accelerating Future Projects

To prevent the friction encountered (ghost states, auth bugs, deployment loops) and increase velocity in future projects, we recommend the following "Day 1" protocols:

### 1. "Cloud First" - No More Mocks
**The Mistake**: We spent time building a robust `localStorage` simulation to "move fast" without setting up a backend.
**The Reality**: The mock logic eventually diverged from how a real DB works, creating "tech debt" and bugs (like data not showing up) that had to be debugged.
**Best Practice**:
*   **Start with the Real DB**: Setting up Firebase/Supabase takes 5 minutes. Do it immediately.
*   **Why**: It forces you to handle asynchronous data, loading states, and error handling *correctly* from the first line of code.

### 2. Strict Auth Boundaries Immediately
**The Mistake**: We allowed a "bypass" mode for testing convenience.
**The Reality**: This masked issues with the actual login flow and route protection, leading to the "empty dashboard" bugs seen later.
**Best Practice**:
*   **No Bypasses**: Even in dev, use the real auth provider (or the provider's official emulator).
*   **Wrap the App**: Create a global `<AuthGuard>` component on Day 1. If `!user`, rendering stops.

### 3. Automated "Sanity" Deployment
**The Mistake**: Manual deployments or debugging build errors only when we were ready to ship.
**The Reality**: Cloud environments (Docker/Linux) act differently than macOS.
**Best Practice**:
*   **Deploy Hello World**: Before writing app code, deploy a generic "Hello World" to the target environment (Cloud Run/Vercel).
*   **Script It**: The `deploy.sh` script should be the *first* file created, not the last.

### 4. Agentic Validation
**The Mistake**: We (the agents) assumed code worked because it compiled.
**The Reality**: Interactive bugs (like the form crash) were only found by *simulating* a user.
**Best Practice**:
*   **Browser Subagent**: We should use the browser subagent to "walk through" the app *after every major feature* is merged, not just at the end.

### 5. UI Component Library
**The Mistake**: Writing custom CSS for every component.
**Best Practice**:
*   **Shadcn/UI**: Continue using this. It was a big win here. It provided polished, accessible components (Cards, Inputs, Buttons) that made the app look premium with minimal effort.

---
*Generated by Antigravity*
