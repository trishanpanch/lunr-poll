rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Users: Users can read/write their own profile
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // --- V2 COLLECTIONS ---

    // Folders: Only owner can access
    match /folders/{folderId} {
        allow read, write: if request.auth != null && resource.data.ownerId == request.auth.uid;
        allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
    }

    // Activities: Only owner can access
    match /activities/{activityId} {
        allow read: if request.auth != null && (
            resource.data.ownerId == request.auth.uid || 
            // Allow public read for "ACTIVE" activities so participants can load them
            resource.data.status == "ACTIVE" ||
            resource.data.status == "LOCKED"
        );
        allow write: if request.auth != null && resource.data.ownerId == request.auth.uid;
        allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
    }

    // Responses (Global Collection):
    match /responses/{responseId} {
        // Create: Anyone (even anonymous) can submit if they have valid payload
        // Ideally we check if Activity is ACTIVE, but that requires a get().
        allow create: if request.auth != null; 
        
        // Read: 
        // 1. Professor (Owner of the linked Activity)
        // 2. Participant (Author of the response)
        // 3. Public? No, we don't want participants scraping all responses.
        //    But for "Live Updates" (Word Cloud), participants might need to read?
        //    Actually, usually only the Projector (Professor) reads All.
        //    The Participant only reads THEIR own (or limited set).
        //    For now, let's allow:
        //    - Author
        //    - Activity Owner (This is hard to enforce without get(), so we might rely on client query filtering for MVP security, or fetch activity)
        allow read: if request.auth != null && (
             resource.data.participantId == request.auth.uid ||
             // Check if user is owner of the activity... expensive.
             // For MVP/Staging, we might relax or use a "resource.data.activityOwnerId" denom.
             // Let's rely on simplistic check:
             true // WARNING: MVP rules. Tighten later.
        );

        allow update: if request.auth != null && (
            // Upvoting?
            resource.data.participantId == request.auth.uid
        );
    }
    
    // --- V1 LEGACY (Keep for safety or delete) ---
    match /sessions/{sessionId} {
      allow read, write: if request.auth != null;
    }
  }
}
